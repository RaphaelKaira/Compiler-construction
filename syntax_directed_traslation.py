#EXPRESSIONS
# E → E + T  { E.place = new_temp(); IR.add(f"{E.place} = {E1.place} + {T.place}") }
# E → T      { E.place = T.place }
# T → T * F  { T.place = new_temp(); IR.add(f"{T.place} = {T1.place} * {F.place}") }
# T → F      { T.place = F.place }
# F → id     { F.place = lookup(id) }
# F → num    { F.place = num }

#CONDITIONALS
# S → if E { S1 } else { S2 } { 
#     IR.add(f"if {E.place} goto L1"); 
#     IR.add(f"goto L2");
#     IR.add(f"L1:"); 
#     IR.append(S1.code);
#     IR.add(f"L2:"); 
#     IR.append(S2.code);
# }

#LOOPS
# S → do { S1 } while ( E ) { 
#     IR.add(f"L1:");
#     IR.append(S1.code);
#     IR.add(f"if {E.place} goto L1");
# }

# Helper function to generate new temporary variables
temp_count = 0
label_count = 0

def new_temp():
    global temp_count
    temp_count += 1
    return f"t{temp_count}"

def new_label():
    global label_count
    label_count += 1
    return f"L{label_count}"

# Intermediate Representation (IR) storage
IR = []

# Grammar rules for SDT with synthesized attributes
class Node:
    def __init__(self, place=None, code=None):
        self.place = place       # Holds the result of expression evaluation
        self.code = code or []   # Holds IR code generated by this node

class SyntaxDirectedTranslator:
    def __init__(self):
        self.IR = []  # IR for the entire program

    # Translate expressions
    def translate_expression(self, left, op, right):
        result = new_temp()
        self.IR.append(f"{result} = {left} {op} {right}")
        return result
    
    # Translate if-else conditionals
    def translate_if_else(self, condition, true_block, false_block):
        true_label = new_label()
        end_label = new_label()
        
        self.IR.append(f"if {condition} goto {true_label}")
        self.IR.extend(false_block)
        self.IR.append(f"goto {end_label}")
        self.IR.append(f"{true_label}:")
        self.IR.extend(true_block)
        self.IR.append(f"{end_label}:")
    
    # Translate do-while loops
    def translate_do_while(self, body, condition):
        start_label = new_label()
        self.IR.append(f"{start_label}:")
        self.IR.extend(body)
        self.IR.append(f"if {condition} goto {start_label}")
    
    # Parse Zara code and generate IR
    def parse(self, tokens):
        # Parsing and translation logic goes here
        # For simplicity, we’ll manually construct a few sample IR representations
        
        # Example expression translation
        left = "x"
        right = "5"
        expr_result = self.translate_expression(left, "+", right)
        
        # Example conditional translation
        condition = f"{expr_result} > 10"
        true_block = [f"{expr_result} = {expr_result} - 1"]
        false_block = [f"{expr_result} = {expr_result} + 1"]
        self.translate_if_else(condition, true_block, false_block)
        
        # Example loop translation
        loop_condition = f"{expr_result} < 100"
        loop_body = [f"{expr_result} = {expr_result} * 2"]
        self.translate_do_while(loop_body, loop_condition)
        
        return self.IR

# Test SDT with a sample Zara code
def test_syntax_directed_translation():
    print("Syntax-Directed Translation Test\n")
    
    # Tokens representing a sample Zara program
    tokens = [
        # Normally, tokens would be generated by the lexical analyzer
    ]
    
    # Initialize translator
    translator = SyntaxDirectedTranslator()
    
    # Parse tokens and generate IR
    IR_code = translator.parse(tokens)
    
    # Print Intermediate Representation
    print("Generated Intermediate Representation (IR):\n")
    for line in IR_code:
        print(line)

# Run test
test_syntax_directed_translation()

